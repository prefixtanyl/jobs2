<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="app-title">‡§ï‡•É‡§∑‡§ø ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞ (‡§ö‡•à‡§ü‡§¨‡•â‡§ü)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#059669', /* Green for the "farmer" theme */
                        'secondary': '#10b981',
                        'chat-bg': '#e0f2f1',
                        'earth': '#78350f'
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom styles for chat interface and fixed language selector */
        body {
            background-color: #fffdfa; /* Warm light golden/cream background */
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }
        .dark body {
            background-color: #111827;
        }
        #chat-container {
            position: relative;
            z-index: 10; /* Ensures the chat UI is above the background effects */
        }
        #chat-window {
            height: 60vh;
            max-height: 60vh;
            overflow-y: auto;
        }
        .user-message {
            background-color: #d1fae5;
            align-self: flex-end;
            border-radius: 12px 12px 0 12px;
        }
        .dark .user-message {
            background-color: #065f46;
            color: #f3f4f6;
        }
        .ai-message {
            background-color: white;
            align-self: flex-start;
            border-radius: 12px 12px 12px 0;
            white-space: pre-wrap;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        .dark .ai-message {
            background-color: #374151;
            color: #f3f4f6;
        }
        /* Language Selector Styling (Small Oval Dropdown Look-alike) */
        #language-selector {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            z-index: 100;
            writing-mode: vertical-lr; /* Vertical text */
            text-orientation: mixed;
            padding: 8px 4px;
            border-radius: 12px 0 0 12px;
            box-shadow: -4px 0 8px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            line-height: 1.5;
        }
        .ai-message a {
            word-break: break-all;
            color: #2563eb;
        }
        .dark .ai-message a {
            color: #60a5fa;
        }

        /* --- Dynamic Background Effects (Sun Rays and Stars) --- */

        /* Base pseudo-element for background effects */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1; /* Place behind all content */
        }

        /* Light Theme: Visible Sun Rays (More visible, new background color) */
        body:not(.dark)::before {
            opacity: 1; 
            background: 
                /* Main, strong ray effect - gold/yellow */
                radial-gradient(circle at 120% 0%, 
                    rgba(255, 215, 0, 0.45) 0%, /* Brighter gold */
                    rgba(255, 255, 255, 0.2) 20%, 
                    transparent 60%),
                /* Secondary, softer ray effect */
                radial-gradient(circle at 100% 0%, 
                    rgba(255, 255, 153, 0.35) 0%, 
                    transparent 45%);
            background-repeat: no-repeat;
            transform-origin: top right; /* Pivot point for rotation */
            
            /* Combine shimmering and a slow rotation */
            animation: sun-shimmer 20s ease-in-out infinite, ray-rotate 60s linear infinite;
        }

        /* Dark Theme: Moving/Twinkling Stars (Denser star field) */
        .dark body::before {
            opacity: 0.95;
            background: #111827; /* Dark background */
            
            /* Denser list of radial gradients for many stars */
            background-image: 
                radial-gradient(0.5px 0.5px at 10% 10%, #fff, transparent),
                radial-gradient(1px 1px at 70% 30%, #fff, transparent),
                radial-gradient(0.5px 0.5px at 40% 60%, #eee, transparent),
                radial-gradient(1.5px 1.5px at 90% 80%, #ccc, transparent),
                radial-gradient(1.5px 1.5px at 20% 40%, #ddd, transparent),
                radial-gradient(1px 1px at 60% 90%, #fff, transparent),
                radial-gradient(0.5px 0.5px at 80% 20%, #eee, transparent),
                radial-gradient(1px 1px at 50% 5%, #fff, transparent),
                radial-gradient(0.5px 0.5px at 35% 95%, #fff, transparent),
                radial-gradient(1px 1px at 5% 50%, #fff, transparent),
                radial-gradient(1.5px 1.5px at 25% 75%, #ccc, transparent),
                radial-gradient(0.5px 0.5px at 85% 15%, #eee, transparent);
            
            background-repeat: repeat;
            background-size: 500px 500px; /* Smaller size for denser pattern */
            background-position: 0 0;
            
            /* Faster drift and twinkling */
            animation: twinkle 4s infinite alternate, background-drift 300s linear infinite;
        }


        /* Keyframes */
        @keyframes sun-shimmer {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes ray-rotate {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(5deg); }
            100% { transform: rotate(0deg); }
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.95; }
            50% { opacity: 0.4; }
        }

        @keyframes background-drift {
            /* Faster, continuous movement */
            from { background-position: 0 0; }
            to { background-position: 20000px 20000px; }
        }

    </style>
</head>
<body class="font-sans flex justify-center items-center p-4 bg-green-50 dark:bg-gray-900">

    <!-- Language Selector Button (Oval, Right Edge) -->
    <button id="language-selector" onclick="toggleLanguage()"
            class="bg-secondary hover:bg-primary text-white text-xs font-semibold transition duration-150 ease-in-out">
        English
    </button>

    <div id="chat-container" class="w-full max-w-xl bg-white dark:bg-gray-800 rounded-xl shadow-2xl overflow-hidden">
        
        <!-- Header -->
        <header class="bg-primary text-white p-4 flex justify-between items-center">
            <h1 id="header-title" class="text-xl font-bold">üåæ ‡§ï‡•É‡§∑‡§ø ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞</h1>
            <div class="flex items-center space-x-4">
                <span id="auth-status" class="text-xs px-2 py-1 rounded-full bg-green-700">‡§§‡•à‡§Ø‡§æ‡§∞</span>
                <button id="theme-toggle" class="p-2 rounded-full hover:bg-green-700 transition">
                    <svg id="theme-icon-light" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                    <svg id="theme-icon-dark" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                </button>
            </div>
        </header>

        <!-- Chat Window -->
        <div id="chat-window" class="p-4 bg-chat-bg dark:bg-gray-700 flex flex-col space-y-4">
            <!-- Messages will be rendered here by renderChatHistory -->
        </div>

        <!-- Input Area (Chatbot Function) -->
        <div id="input-area" class="p-4 bg-gray-50 dark:bg-gray-900 border-t border-gray-200 dark:border-gray-700">
            
            <!-- Image Preview Area -->
            <div id="image-preview-container" class="mb-3 p-2 border border-gray-300 dark:border-gray-600 rounded-lg hidden relative">
                <img id="image-preview" class="max-h-24 w-auto rounded-md object-contain mx-auto" alt="Image preview">
                <button onclick="clearImage()" class="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1 leading-none text-xs w-6 h-6 flex items-center justify-center shadow-lg hover:bg-red-600 transition">
                    &times;
                </button>
            </div>

            <!-- Input Row -->
            <div class="flex items-center space-x-0 w-full"> 
                
                <!-- Hidden File Input -->
                <input type="file" id="image-upload" accept="image/*" class="hidden" onchange="handleImageSelection()">

                <!-- 1. Camera Button (Rounded Left) -->
                <button id="upload-btn" onclick="document.getElementById('image-upload').click()" 
                        class="bg-gray-300 hover:bg-gray-400 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-300 font-bold p-3 rounded-l-lg transition duration-150 ease-in-out disabled:opacity-50 flex-shrink-0 z-10" 
                        title="Image Upload">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-camera"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>
                </button>
                
                <!-- 2. Mic Button (No Rounding) -->
                <button id="mic-btn" onclick="toggleVoiceInput()" 
                        class="bg-gray-300 hover:bg-gray-400 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-300 font-bold p-3 transition duration-150 ease-in-out disabled:opacity-50 flex-shrink-0 z-10 -ml-px"
                        title="Start Voice Input">
                    <svg id="mic-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mic"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>
                </button>

                <!-- 3. Text Input (No Rounding, uses border) -->
                <input type="text" id="chat-input" placeholder="‡§è‡§ï ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§™‡•Ç‡§õ‡•á‡§Ç..."
                       class="flex-grow p-3 border border-gray-300 dark:bg-gray-800 dark:border-gray-600 dark:text-white dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-secondary focus:border-transparent -ml-px z-0">
                
                <!-- 4. Send Button (Rounded Right) -->
                <button id="send-btn" onclick="handleUserInput()" 
                        class="bg-primary hover:bg-secondary text-white font-bold py-3 px-4 rounded-r-lg transition duration-150 ease-in-out disabled:opacity-50 flex-shrink-0 -ml-px z-10">
                    ‡§≠‡•á‡§ú‡•á‡§Ç
                </button>
            </div>
        </div>

        <!-- Hidden Error/Debug Display -->
        <div id="error-message" class="p-2 bg-red-100 dark:bg-red-900/50 text-red-600 dark:text-red-400 text-xs hidden"></div>
        <div id="debug-info" class="p-2 text-gray-500 dark:text-gray-400 text-xs text-center border-t border-gray-100 dark:border-gray-700 flex justify-between items-center">
            <span id="debug-lang-info"></span>
            <button id="credits-btn" class="text-xs text-blue-500 hover:underline">Credits</button>
        </div>
    </div>

    <!-- Credits Modal -->
    <div id="credits-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center">
            <h3 class="text-lg font-bold text-gray-900 dark:text-white mb-2">Credits</h3>
            <p id="credits-text-content" class="text-sm text-gray-600 dark:text-gray-300 mb-4"></p>
            <button id="close-credits-btn" class="bg-primary hover:bg-secondary text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out">
                Close
            </button>
        </div>
    </div>


    <!-- Core Logic -->
    <script type="module">
        
        // --- Gemini API Configuration ---
        const apiKey = "AIzaSyB8Nd8wFuqQtrlSK2UjyGULwlz2QYGvYU8"; // API key is handled by the environment
        const GEMINI_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent';
        const TTS_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent';
        
        // --- Customizable Credits Text ---
        const creditsText = "This Conversational Farm Advisor was built by a brilliant developer using Gemini.";

        // --- Localization Data (Simplified) ---
        const TEXTS = {
            'en': {
                title: "Farm Advisor Chatbot",
                ready: "Ready",
                placeholder: "Ask a question about your crop, or upload an image...",
                send: "Send",
                init_welcome: "Hello! I'm Krishi Mitra, your expert Farm Advisor. Upload an image of your crop/pest issue and ask me a question, or just ask general advice. Click the speaker icon to hear my advice!",
                api_error: "API Error",
                language_text: "English",
                processing_error: "Sorry, I ran into an error getting a response from the advisor. Please try again.",
                upload_image: "Upload Image",
                clear_image: "Clear Image",
                listen_advice: "Listen to Advice",
                tts_error: "TTS Error",
                audio_playback_error: "Audio playback error",
                start_mic: "Start Voice Input",
                listening: "Listening...",
                tts_data_error: "Audio data section missing or empty in API response. Try a different voice or simpler text.",
                translation_error: "Failed to translate chat history.",
                translating: "Translating..."
            },
            'hi': {
                title: "‡§ï‡•É‡§∑‡§ø ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞ (‡§ö‡•à‡§ü‡§¨‡•â‡§ü)",
                ready: "‡§§‡•à‡§Ø‡§æ‡§∞",
                placeholder: " ‡§Ö‡§™‡§®‡•Ä ‡§´‡§∏‡§≤ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§™‡•Ç‡§õ‡•á‡§Ç, ‡§Ø‡§æ ‡§è‡§ï ‡§õ‡§µ‡§ø ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç...",
                send: "‡§≠‡•á‡§ú‡•á‡§Ç",
                init_welcome: "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§ï‡•É‡§∑‡§ø ‡§Æ‡§ø‡§§‡•ç‡§∞, ‡§Ü‡§™‡§ï‡§æ ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§ï‡•É‡§∑‡§ø ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞ ‡§π‡•Ç‡§Å‡•§ ‡§Ö‡§™‡§®‡•Ä ‡§´‡§∏‡§≤/‡§ï‡•Ä‡§ü ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•Ä ‡§è‡§ï ‡§õ‡§µ‡§ø ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§Æ‡•Å‡§ù‡§∏‡•á ‡§è‡§ï ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§™‡•Ç‡§õ‡•á‡§Ç, ‡§Ø‡§æ ‡§¨‡§∏ ‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∏‡§≤‡§æ‡§π ‡§≤‡•á‡§Ç‡•§ ‡§Æ‡•á‡§∞‡•Ä ‡§∏‡§≤‡§æ‡§π ‡§∏‡•Å‡§®‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•ç‡§™‡•Ä‡§ï‡§∞ ‡§Ü‡§á‡§ï‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç!",
                api_error: "‡§è‡§™‡•Ä‡§Ü‡§à ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø",
                language_text: "‡§π‡§ø‡§Ç‡§¶‡•Ä",
                processing_error: "‡§ï‡•ç‡§∑‡§Æ‡§æ ‡§ï‡§∞‡•á‡§Ç, ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞ ‡§∏‡•á ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®: ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
                upload_image: "‡§õ‡§µ‡§ø ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç",
                clear_image: "‡§õ‡§µ‡§ø ‡§π‡§ü‡§æ‡§è‡§Ç",
                listen_advice: "‡§∏‡§≤‡§æ‡§π ‡§∏‡•Å‡§®‡•á‡§Ç",
                tts_error: "‡§ü‡•Ä‡§ü‡•Ä‡§è‡§∏ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø",
                audio_playback_error: "‡§ë‡§°‡§ø‡§Ø‡•ã ‡§ö‡§≤‡§æ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø",
                start_mic: "‡§Ü‡§µ‡§æ‡§ú ‡§á‡§®‡§™‡•Å‡§ü ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
                listening: "‡§∏‡•Å‡§® ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å...",
                tts_data_error: "‡§è‡§™‡•Ä‡§Ü‡§à ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§Æ‡•á‡§Ç ‡§ë‡§°‡§ø‡§Ø‡•ã ‡§°‡•á‡§ü‡§æ ‡§Ö‡§®‡•Å‡§≠‡§æ‡§ó ‡§ó‡§æ‡§Ø‡§¨ ‡§Ø‡§æ ‡§ñ‡§æ‡§≤‡•Ä ‡§π‡•à‡•§ ‡§ï‡•ã‡§à ‡§≠‡§ø‡§®‡•ç‡§® ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§Ø‡§æ ‡§∏‡§∞‡§≤ ‡§™‡§æ‡§† ‡§Ü‡§ú‡§º‡§Æ‡§æ‡§è‡§Å‡•§",
                translation_error: "‡§ö‡•à‡§ü ‡§á‡§§‡§ø‡§π‡§æ‡§∏ ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§",
                translating: "‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à..."
            }
        };

        // --- Global State ---
        let chatHistory = []; // Data model for the chat
        let currentLanguage = localStorage.getItem('krishiMitraLang') || 'hi'; // Default to Hindi
        let isReady = false; // Tracks if the basic setup is done
        let uploadedImageBase64 = null;
        let uploadedImageMimeType = null;
        let currentAudio = null; // To hold the currently playing audio element
        let recognition = null; // Holds the SpeechRecognition object
        let isListening = false;


        // --- DOM Elements ---
        const appTitleEl = document.getElementById('app-title');
        const headerTitleEl = document.getElementById('header-title');
        const authStatusEl = document.getElementById('auth-status');
        const chatWindowEl = document.getElementById('chat-window');
        const errorMessageEl = document.getElementById('error-message');
        const debugLangInfoEl = document.getElementById('debug-lang-info');
        const langSelectorEl = document.getElementById('language-selector');
        const chatInputEl = document.getElementById('chat-input');
        const sendBtnEl = document.getElementById('send-btn');
        const imageUploadEl = document.getElementById('image-upload');
        const imagePreviewContainerEl = document.getElementById('image-preview-container');
        const imagePreviewEl = document.getElementById('image-preview');
        const micBtnEl = document.getElementById('mic-btn');
        const micIconEl = document.getElementById('mic-icon');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const creditsBtn = document.getElementById('credits-btn');
        const creditsModal = document.getElementById('credits-modal');
        const closeCreditsBtn = document.getElementById('close-credits-btn');
        const creditsTextContentEl = document.getElementById('credits-text-content');


        // --- Utility Functions ---

        function setUIState(isLoading, isTranslating = false) {
            const shouldDisable = isLoading || !isReady || isListening || isTranslating;
            
            sendBtnEl.disabled = shouldDisable;
            chatInputEl.disabled = shouldDisable;
            imageUploadEl.disabled = shouldDisable;
            micBtnEl.disabled = shouldDisable;
            
            if (!isListening) {
                 chatInputEl.placeholder = isLoading ? getT('processing_error') : (isTranslating ? getT('translating') : getT('placeholder'));
            }
            
            sendBtnEl.innerHTML = isLoading || isTranslating ? 
                `<svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>` : 
                getT('send');
        }

        function displayError(message) {
            errorMessageEl.textContent = message;
            errorMessageEl.classList.remove('hidden');
            console.error(message);
        }
        
        function getOriginalIconHtml(listenText) {
            return `
                <span class="sr-only">${listenText}</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
            `;
        }

        // --- Chat Rendering ---
        async function renderChatHistory() {
            chatWindowEl.innerHTML = ''; 

            const translationTasks = [];
            chatHistory.forEach((msg, index) => {
                if (!msg.translations[currentLanguage]) {
                    const sourceLang = Object.keys(msg.translations)[0];
                    if (sourceLang) {
                        const sourceText = msg.translations[sourceLang];
                        translationTasks.push({ index, text: sourceText });
                    }
                }
            });

            if (translationTasks.length > 0) {
                setUIState(false, true);
                const translationPromises = translationTasks.map(task => translateText(task.text, currentLanguage));
                try {
                    const translatedTexts = await Promise.all(translationPromises);
                    translatedTexts.forEach((translatedText, i) => {
                        const task = translationTasks[i];
                        chatHistory[task.index].translations[currentLanguage] = translatedText;
                    });
                } catch (e) {
                    displayError(`${getT('translation_error')} ${e.message}`);
                } finally {
                    setUIState(false);
                }
            }

            chatHistory.forEach(msg => {
                const textToDisplay = msg.translations[currentLanguage] || msg.text;
                const messageDiv = document.createElement('div');
                messageDiv.className = `p-3 max-w-[80%] ${msg.isUser ? 'user-message ml-auto' : 'ai-message'}`;

                let innerHTML = '';
                if (!msg.isUser) {
                    let responseHtml = textToDisplay
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')
                        .replace(/\n/g, '<br>');

                    if (msg.citations && msg.citations.length > 0) {
                        responseHtml += `<p class="mt-2 pt-2 border-t border-gray-100 dark:border-gray-600 text-[10px] text-gray-500 dark:text-gray-400 font-medium">${currentLanguage === 'hi' ? '‡§∏‡•ç‡§∞‡•ã‡§§' : 'Sources'}: `;
                        msg.citations.forEach((source, index) => {
                            responseHtml += `<a href="${source.uri}" target="_blank" class="hover:underline">${source.title || 'Link'}</a>${index < msg.citations.length - 1 ? ', ' : ''}`;
                        });
                        responseHtml += '</p>';
                    }
                    const rawTextForTTS = msg.translations[currentLanguage] || msg.text;
                    const escapedRawText = rawTextForTTS.replace(/'/g, "\\'").replace(/\n/g, ' ');
                    innerHTML = `<div class="flex justify-between items-start w-full"><div class="flex-grow break-words">${responseHtml}</div><button onclick="playTts(this, '${escapedRawText}', '${currentLanguage}')" class="ml-2 p-1 rounded-full bg-secondary hover:bg-primary text-white transition duration-150 ease-in-out flex-shrink-0 shadow-md flex items-center justify-center" title="${getT('listen_advice')}">${getOriginalIconHtml(getT('listen_advice'))}</button></div>`;
                } else {
                    innerHTML = textToDisplay;
                    if (msg.imageUrl) {
                        innerHTML += `<div class="mt-2 p-1 border border-gray-200 dark:border-gray-600 rounded-md"><img src="${msg.imageUrl}" class="max-h-24 w-auto rounded-sm mx-auto object-contain" alt="Attached image"></div>`;
                    }
                }
                messageDiv.innerHTML = innerHTML;
                chatWindowEl.appendChild(messageDiv);
            });
            chatWindowEl.scrollTop = chatWindowEl.scrollHeight;
        }

        // --- Theme and Localization Functions ---
        function getT(key) {
            return TEXTS[currentLanguage][key];
        }

        function initializeTheme() {
            const theme = localStorage.getItem('theme');
            if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
                themeIconLight.classList.add('hidden');
                themeIconDark.classList.remove('hidden');
            } else {
                document.documentElement.classList.remove('dark');
                themeIconLight.classList.remove('hidden');
                themeIconDark.classList.add('hidden');
            }
        }

        function toggleTheme() {
            const isDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            themeIconLight.classList.toggle('hidden', isDark);
            themeIconDark.classList.toggle('hidden', !isDark);
        }
        
        window.translateUI = function() {
            appTitleEl.textContent = getT('title');
            headerTitleEl.textContent = `üåæ ${getT('title')}`;
            langSelectorEl.textContent = currentLanguage === 'hi' ? TEXTS['en'].language_text : TEXTS['hi'].language_text;
            authStatusEl.textContent = getT('ready');
            micBtnEl.title = isListening ? getT('listening') : getT('start_mic');
            chatInputEl.placeholder = isListening ? getT('listening') : getT('placeholder');
            sendBtnEl.textContent = getT('send');
            debugLangInfoEl.textContent = `Lang: ${currentLanguage}`;
            if (recognition && !isListening) {
                recognition.lang = currentLanguage === 'hi' ? 'hi-IN' : 'en-US';
            }
            if (isReady) setUIState(false);
        }
        
        window.toggleLanguage = function() {
            currentLanguage = currentLanguage === 'hi' ? 'en' : 'hi';
            localStorage.setItem('krishiMitraLang', currentLanguage);
            translateUI();
            renderChatHistory(); // Re-render chat with new language
        }


        // --- Image Handling ---
        window.handleImageSelection = function() {
            const file = imageUploadEl.files[0];
            if (!file) return;
            if (!file.type.startsWith('image/')) {
                displayError(getT('language') === 'hi' ? "‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§µ‡•à‡§ß ‡§õ‡§µ‡§ø ‡§´‡§º‡§æ‡§á‡§≤ ‡§ö‡•Å‡§®‡•á‡§Ç‡•§" : "Please select a valid image file.");
                clearImage();
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedImageMimeType = file.type;
                uploadedImageBase64 = e.target.result.split(',')[1];
                imagePreviewEl.src = e.target.result;
                imagePreviewContainerEl.classList.remove('hidden');
            };
            reader.onerror = () => {
                displayError(getT('language') === 'hi' ? "‡§õ‡§µ‡§ø ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø‡•§" : "Error loading image.");
                clearImage();
            };
            reader.readAsDataURL(file);
        }

        window.clearImage = function() {
            uploadedImageBase64 = null;
            uploadedImageMimeType = null;
            imageUploadEl.value = null;
            imagePreviewEl.src = '';
            imagePreviewContainerEl.classList.add('hidden');
        }


        // --- TTS Utility Functions ---
        const VOICE_MAP = { 'hi': 'Algenib', 'en': 'Kore' };

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const buffer = new ArrayBuffer(44 + pcm16.length * 2);
            const view = new DataView(buffer);
            const write = (offset, str) => str.split('').forEach((c, i) => view.setUint8(offset + i, c.charCodeAt(0)));
            write(0, 'RIFF');
            view.setUint32(4, 36 + pcm16.length * 2, true);
            write(8, 'WAVE');
            write(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            write(36, 'data');
            view.setUint32(40, pcm16.length * 2, true);
            pcm16.forEach((sample, i) => view.setInt16(44 + i * 2, sample, true));
            return new Blob([view], { type: 'audio/wav' });
        }
        
        function splitIntoSentences(text) {
            return (text.match(/[^.!?\n]+([.!?\n]|$)/g) || [text]).map(s => s.trim()).filter(s => s.length > 0);
        }
        
        async function fetchAudioChunk(chunkText, language) {
            const payload = {
                contents: [{ parts: [{ text: chunkText }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: { prebuiltVoiceConfig: { voiceName: VOICE_MAP[language] || 'Kore' } },
                        languageCode: language === 'hi' ? 'hi-IN' : 'en-US'
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };
            const response = await fetchWithRetry(`${TTS_URL}?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            if (!part || !part.inlineData?.data) throw new Error(getT('tts_error') + ': ' + getT('tts_data_error'));
            if (part.inlineData.mimeType.startsWith("audio/L16")) {
                const rateMatch = part.inlineData.mimeType.match(/rate=(\d+)/);
                if (!rateMatch) throw new Error(getT('tts_error') + ': Could not determine audio sample rate.');
                const pcm16 = new Int16Array(base64ToArrayBuffer(part.inlineData.data));
                return URL.createObjectURL(pcmToWav(pcm16, parseInt(rateMatch[1], 10)));
            }
            throw new Error(getT('tts_error') + ': Unexpected audio MIME type.');
        }

        window.playTts = async function(buttonEl, rawText, language) {
            if (currentAudio) currentAudio.pause();
            buttonEl.disabled = true;
            const listenText = getT('listen_advice');
            buttonEl.innerHTML = `<svg class="animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span class="sr-only">${listenText}</span>`;
            
            const textToSpeak = rawText.replace(/(\*\*|`)/g, '').replace(/\[Image Attached\]|\[‡§õ‡§µ‡§ø ‡§∏‡§Ç‡§≤‡§ó‡•ç‡§®\]/gi, '').trim();
            if (!textToSpeak) {
                displayError(getT('tts_error') + ': Cannot speak empty text.');
                buttonEl.innerHTML = getOriginalIconHtml(listenText);
                buttonEl.disabled = false;
                return;
            }

            const chunks = splitIntoSentences(textToSpeak);
            try {
                for (const chunk of chunks) {
                    const audioUrl = await fetchAudioChunk(chunk, language);
                    currentAudio = new Audio(audioUrl);
                    currentAudio.play();
                    await new Promise((resolve, reject) => {
                        currentAudio.onended = () => { URL.revokeObjectURL(audioUrl); resolve(); };
                        currentAudio.onerror = (e) => { URL.revokeObjectURL(audioUrl); reject(e); };
                    });
                }
            } catch (e) {
                displayError(`${getT('tts_error')}: ${e.message}`);
            } finally {
                buttonEl.innerHTML = getOriginalIconHtml(listenText);
                buttonEl.disabled = false;
                currentAudio = null;
            }
        }


        // --- General Gemini API Logic ---
        async function fetchWithRetry(url, options, maxRetries = 5) {
            let delay = 1000;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429) throw new Error('Rate Limit Exceeded');
                    if (!response.ok) throw new Error(`API response status ${response.status}: ${await response.text()}`);
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
        }

        async function translateText(text, targetLang) {
            if (!text || !text.trim()) return '';
            const langName = targetLang === 'hi' ? 'Hindi' : 'English';
            const prompt = `Translate the following text into ${langName}. Respond with ONLY the translated text, without any introductory phrases or quotation marks. Text to translate: "${text}"`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            const options = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) };
            try {
                const response = await fetchWithRetry(`${GEMINI_URL}?key=${apiKey}`, options);
                const result = await response.json();
                const translated = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (translated) return translated.trim().replace(/^"(.*)"$/, '$1');
                throw new Error("No translated text in API response.");
            } catch (error) {
                console.error("Translation failed:", error);
                return text; // Fallback
            }
        }

        async function generateGeminiResponse(query, imageBase64, imageMimeType, language) {
            const systemInstruction = (language === 'hi' ? 
                `‡§Ü‡§™ ‡§è‡§ï ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§ï‡•É‡§∑‡§ø ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞ ‡§π‡•à‡§Ç, ‡§ú‡§ø‡§®‡•ç‡§π‡•á‡§Ç '‡§ï‡•É‡§∑‡§ø ‡§Æ‡§ø‡§§‡•ç‡§∞' ‡§ï‡§π‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ ‡§Ü‡§™‡§ï‡•Ä ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ‡§è‡§Ç ‡§π‡§Æ‡•á‡§∂‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§π‡•ã‡§®‡•Ä ‡§ö‡§æ‡§π‡§ø‡§è‡•§ ‡§Ü‡§™ Google Search ‡§î‡§∞ ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡•Ä ‡§ó‡§à ‡§õ‡§µ‡§ø ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§ï‡•á ‡§ï‡§ø‡§∏‡§æ‡§® ‡§ï‡•Ä ‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡§æ ‡§®‡§ø‡§¶‡§æ‡§® ‡§î‡§∞ ‡§â‡§™‡§ö‡§æ‡§∞ ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á‡•§ ‡§∏‡§Ç‡§ï‡•ç‡§∑‡•á‡§™ ‡§Æ‡•á‡§Ç ‡§î‡§∞ ‡§â‡§™‡§Ø‡•ã‡§ó‡•Ä ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç‡•§` :
                `You are an expert Indian agricultural advisor named 'Krishi Mitra'. Your responses must always be in English. Use Google Search and the provided image to diagnose crop problems and suggest solutions. Be concise and helpful.`
            );
            const contentsParts = [{ text: query }];
            if (imageBase64 && imageMimeType) {
                contentsParts.push({ inlineData: { mimeType: imageMimeType, data: imageBase64 } });
            }
            const payload = {
                contents: [{ parts: contentsParts }],
                tools: [{ "google_search": {} }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
            };
            const response = await fetchWithRetry(`${GEMINI_URL}?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            const result = await response.json();
            const candidate = result.candidates?.[0];
            if (candidate && candidate.content?.parts?.[0]?.text) {
                const text = candidate.content.parts[0].text;
                const groundingMetadata = candidate.groundingMetadata;
                const sources = (groundingMetadata?.groundingAttributions || [])
                    .map(attr => ({ uri: attr.web?.uri, title: attr.web?.title }))
                    .filter(s => s.uri && s.title);
                return { text, sources };
            }
            throw new Error(JSON.stringify(result.promptFeedback || 'No text content returned.'));
        }

        // --- Speech Recognition Logic ---
        function setMicUIState(listening) {
            if (listening) {
                micBtnEl.title = getT('listening');
                micIconEl.classList.add('text-red-500', 'animate-pulse');
            } else {
                micBtnEl.title = getT('start_mic');
                micIconEl.classList.remove('text-red-500', 'animate-pulse');
            }
            setUIState(false);
        }

        window.toggleVoiceInput = function() {
            if (!recognition) return displayError('Speech Recognition is not supported.');
            if (isListening) recognition.stop();
            else {
                recognition.lang = currentLanguage === 'hi' ? 'hi-IN' : 'en-US';
                recognition.start();
            }
        }
        
        function setupSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.continuous = false; 
                recognition.interimResults = true; 
                recognition.onstart = () => { isListening = true; setMicUIState(true); chatInputEl.placeholder = getT('listening'); };
                recognition.onresult = (event) => {
                    let finalTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
                    }
                    chatInputEl.value = finalTranscript || event.results[event.resultIndex][0].transcript;
                };
                recognition.onerror = (event) => console.error('Speech Recognition Error:', event.error);
                recognition.onend = () => {
                    isListening = false;
                    setMicUIState(false);
                    if (chatInputEl.value.trim()) handleUserInput();
                    else chatInputEl.placeholder = getT('placeholder');
                };
            } else micBtnEl.disabled = true;
        }

        // --- Chatbot Input Handling ---
        window.handleUserInput = async function() {
            const userInput = chatInputEl.value.trim();
            errorMessageEl.classList.add('hidden');
            const hasImage = !!uploadedImageBase64;
            if (!userInput && !hasImage) return;
            if (!isReady || isListening) return;

            chatHistory.push({
                isUser: true,
                text: userInput,
                translations: { [currentLanguage]: userInput },
                imageUrl: hasImage ? imagePreviewEl.src : null,
                citations: null
            });
            const queryForAI = hasImage ? `[${getT('upload_image')}] ${userInput}` : userInput;
            const tempBase64 = uploadedImageBase64;
            const tempMimeType = uploadedImageMimeType;
            chatInputEl.value = '';
            clearImage();
            renderChatHistory();
            setUIState(true);

            try {
                const { text: aiResponseText, sources: citations } = await generateGeminiResponse(queryForAI, tempBase64, tempMimeType, currentLanguage);
                chatHistory.push({
                    isUser: false,
                    text: aiResponseText,
                    translations: { [currentLanguage]: aiResponseText },
                    imageUrl: null,
                    citations: citations
                });
            } catch (e) {
                chatHistory.push({
                    isUser: false,
                    text: getT('processing_error'),
                    translations: { en: TEXTS.en.processing_error, hi: TEXTS.hi.processing_error },
                    imageUrl: null,
                    citations: null
                });
                displayError(`${getT('api_error')}: ${e.message}`);
            } finally {
                setUIState(false);
                renderChatHistory();
            }
        }
        
        chatInputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !sendBtnEl.disabled) handleUserInput();
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeTheme();
            setupSpeechRecognition();
            translateUI(); 

            themeToggleBtn.addEventListener('click', toggleTheme);
            
            creditsBtn.addEventListener('click', () => {
                creditsTextContentEl.textContent = creditsText;
                creditsModal.classList.remove('hidden');
            });

            closeCreditsBtn.addEventListener('click', () => {
                creditsModal.classList.add('hidden');
            });

            creditsModal.addEventListener('click', (e) => {
                if (e.target === creditsModal) {
                    creditsModal.classList.add('hidden');
                }
            });
            
            chatHistory.push({
                isUser: false,
                text: TEXTS.en.init_welcome,
                translations: { en: TEXTS.en.init_welcome, hi: TEXTS.hi.init_welcome },
                imageUrl: null,
                citations: null
            });
            isReady = true;
            setUIState(false);
            renderChatHistory();
        });
        
    </script>
</body>
</html>
